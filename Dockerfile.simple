# Use a specific node version for better compatibility
FROM node:20-alpine

# Set environment variables
ENV NODE_ENV=production

# Install required tools
RUN apk add --no-cache wget nginx netcat-openbsd curl

# Set working directory
WORKDIR /app

# Copy package files first for better layer caching
COPY package.json pnpm-lock.yaml pnpm-workspace.yaml nx.json ./
COPY packages/web/common/package.json ./packages/web/common/
COPY packages/web/backend/package.json ./packages/web/backend/
COPY packages/web/frontend/package.json ./packages/web/frontend/

# Install dependencies
RUN npm install -g pnpm@10.6.1 nx && \
    pnpm install --frozen-lockfile

# Copy the rest of the source code
COPY . .

# Build all packages
RUN pnpm build:web:common && \
    pnpm build:web:backend && \
    pnpm build:web:frontend

# Install production dependencies in the dist folder for backend
RUN cd dist/packages/web/backend/src && \
    echo '{"name":"backend-src","version":"1.0.0","main":"index.js","type":"commonjs","dependencies":{"bcryptjs":"^3.0.2","cors":"^2.8.5","csrf":"^3.1.0","dotenv":"^16.4.7","drizzle-orm":"^0.40.0","express":"^4.18.2","express-rate-limit":"^7.5.0","helmet":"^8.1.0","jsonwebtoken":"^9.0.2","passport":"^0.7.0","passport-apple":"^2.0.2","passport-github2":"^0.1.12","passport-google-oauth20":"^2.0.0","pg":"^8.13.3","pg-pool":"^3.8.0","zod":"^3.24.2","cookie-parser":"^1.4.6","morgan":"^1.10.0","body-parser":"^1.20.2","compression":"^1.7.4","express-session":"^1.17.3","passport-local":"^1.0.0","passport-jwt":"^4.0.1","uuid":"^9.0.1"}}' > package.json && \
    npm install --production && \
    ls -la && \
    ls -la node_modules

# Fallback approach to ensure dependencies are available
RUN npm install -g bcryptjs cors csrf dotenv drizzle-orm express express-rate-limit helmet jsonwebtoken passport passport-apple passport-github2 passport-google-oauth20 pg pg-pool zod cookie-parser morgan body-parser compression express-session passport-local passport-jwt uuid && \
    echo "Global dependencies installed:"  && \
    npm list -g --depth=0

# Check if the build directories exist and list their contents
RUN echo "Checking build directories and files:" && \
    ls -la dist/ || echo "dist directory not found!" && \
    find dist -type f | grep -i "index.js" || echo "No index.js files found in dist directory structure"

# Create nginx configuration for frontend
RUN mkdir -p /nginx && \
    echo 'events {' > /nginx/frontend.conf && \
    echo '    worker_connections 1024;' >> /nginx/frontend.conf && \
    echo '}' >> /nginx/frontend.conf && \
    echo '' >> /nginx/frontend.conf && \
    echo 'http {' >> /nginx/frontend.conf && \
    echo '    include       /etc/nginx/mime.types;' >> /nginx/frontend.conf && \
    echo '    default_type  application/octet-stream;' >> /nginx/frontend.conf && \
    echo '    ' >> /nginx/frontend.conf && \
    echo '    sendfile        on;' >> /nginx/frontend.conf && \
    echo '    keepalive_timeout  65;' >> /nginx/frontend.conf && \
    echo '    ' >> /nginx/frontend.conf && \
    echo '    server {' >> /nginx/frontend.conf && \
    echo '        listen 80;' >> /nginx/frontend.conf && \
    echo '        root /app/packages/web/frontend/dist;' >> /nginx/frontend.conf && \
    echo '        index index.html;' >> /nginx/frontend.conf && \
    echo '        ' >> /nginx/frontend.conf && \
    echo '        # Enable gzip compression' >> /nginx/frontend.conf && \
    echo '        gzip on;' >> /nginx/frontend.conf && \
    echo '        gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;' >> /nginx/frontend.conf && \
    echo '        ' >> /nginx/frontend.conf && \
    echo '        # Add test endpoint' >> /nginx/frontend.conf && \
    echo '        location = /test {' >> /nginx/frontend.conf && \
    echo '            add_header Content-Type text/plain;' >> /nginx/frontend.conf && \
    echo '            return 200 "Frontend is running";' >> /nginx/frontend.conf && \
    echo '        }' >> /nginx/frontend.conf && \
    echo '        ' >> /nginx/frontend.conf && \
    echo '        # Handle SPA routing' >> /nginx/frontend.conf && \
    echo '        location / {' >> /nginx/frontend.conf && \
    echo '            try_files $uri $uri/ /index.html;' >> /nginx/frontend.conf && \
    echo '            add_header Cache-Control "no-cache, must-revalidate, max-age=0";' >> /nginx/frontend.conf && \
    echo '        }' >> /nginx/frontend.conf && \
    echo '        ' >> /nginx/frontend.conf && \
    echo '        # Cache static assets' >> /nginx/frontend.conf && \
    echo '        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {' >> /nginx/frontend.conf && \
    echo '            expires 30d;' >> /nginx/frontend.conf && \
    echo '            add_header Cache-Control "public, max-age=2592000";' >> /nginx/frontend.conf && \
    echo '        }' >> /nginx/frontend.conf && \
    echo '    }' >> /nginx/frontend.conf && \
    echo '}' >> /nginx/frontend.conf

# Create wait-for-postgres script
RUN echo '#!/bin/sh' > /app/wait-for-postgres.sh && \
    echo 'set -e' >> /app/wait-for-postgres.sh && \
    echo 'host="$1"; shift' >> /app/wait-for-postgres.sh && \
    echo 'port="$1"; shift' >> /app/wait-for-postgres.sh && \
    echo 'cmd="$@"' >> /app/wait-for-postgres.sh && \
    echo 'echo "Waiting for PostgreSQL at $host:$port..."' >> /app/wait-for-postgres.sh && \
    echo 'max_attempts=30' >> /app/wait-for-postgres.sh && \
    echo 'count=0' >> /app/wait-for-postgres.sh && \
    echo 'until nc -z "$host" "$port" > /dev/null 2>&1; do' >> /app/wait-for-postgres.sh && \
    echo '  count=$((count + 1))' >> /app/wait-for-postgres.sh && \
    echo '  if [ $count -ge $max_attempts ]; then' >> /app/wait-for-postgres.sh && \
    echo '    echo "Error: PostgreSQL is still unavailable after $max_attempts attempts"' >> /app/wait-for-postgres.sh && \
    echo '    echo "Last attempt details: Host=$host, Port=$port"' >> /app/wait-for-postgres.sh && \
    echo '    echo "Proceeding anyway, but service may fail if database is required"' >> /app/wait-for-postgres.sh && \
    echo '    break' >> /app/wait-for-postgres.sh && \
    echo '  fi' >> /app/wait-for-postgres.sh && \
    echo '  echo "PostgreSQL is unavailable at $host:$port - attempt $count/$max_attempts, sleeping 1s"' >> /app/wait-for-postgres.sh && \
    echo '  sleep 1' >> /app/wait-for-postgres.sh && \
    echo 'done' >> /app/wait-for-postgres.sh && \
    echo 'if [ $count -lt $max_attempts ]; then' >> /app/wait-for-postgres.sh && \
    echo '  echo "PostgreSQL is up at $host:$port - executing command"' >> /app/wait-for-postgres.sh && \
    echo 'fi' >> /app/wait-for-postgres.sh && \
    echo 'exec $cmd' >> /app/wait-for-postgres.sh && \
    chmod +x /app/wait-for-postgres.sh

# Create startup script
RUN echo '#!/bin/sh' > /app/start.sh && \
    echo 'set -e' >> /app/start.sh && \
    echo 'echo "Starting service with SERVICE_TYPE=$SERVICE_TYPE"' >> /app/start.sh && \
    echo 'if [ "$SERVICE_TYPE" = "backend" ]; then' >> /app/start.sh && \
    echo '  echo "Starting backend service..."' >> /app/start.sh && \
    echo '  cd /app' >> /app/start.sh && \
    echo '  echo "Environment: NODE_ENV=$NODE_ENV, PORT=$PORT, DB_HOST=$DB_HOST, DB_PORT=$DB_PORT"' >> /app/start.sh && \
    echo '  echo "Checking database connection..."' >> /app/start.sh && \
    echo '  /app/wait-for-postgres.sh $DB_HOST $DB_PORT echo "Database is ready"' >> /app/start.sh && \
    echo '  echo "Looking for backend index file..."' >> /app/start.sh && \
    echo '  BACKEND_INDEX=$(find /app/dist -name "index.js" | grep -i "packages/web/backend" | head -n 1)' >> /app/start.sh && \
    echo '  if [ -z "$BACKEND_INDEX" ]; then' >> /app/start.sh && \
    echo '    echo "ERROR: Could not find backend index.js file"' >> /app/start.sh && \
    echo '    echo "Files in dist directory:"' >> /app/start.sh && \
    echo '    find /app/dist -type f | sort' >> /app/start.sh && \
    echo '    exit 1' >> /app/start.sh && \
    echo '  fi' >> /app/start.sh && \
    echo '  echo "Starting backend server with entry point: $BACKEND_INDEX"' >> /app/start.sh && \
    echo '  cd $(dirname $BACKEND_INDEX)' >> /app/start.sh && \
    echo '  echo "Running from directory: $(pwd)"' >> /app/start.sh && \
    echo '  ls -la node_modules || echo "No node_modules found in current directory"' >> /app/start.sh && \
    echo '  echo "Setting NODE_PATH to include multiple module paths"' >> /app/start.sh && \
    echo '  export NODE_PATH="$(pwd)/node_modules:/usr/local/lib/node_modules:$NODE_PATH"' >> /app/start.sh && \
    echo '  echo "NODE_PATH=$NODE_PATH"' >> /app/start.sh && \
    echo '  echo "Looking for express in NODE_PATH..."' >> /app/start.sh && \
    echo '  find $(echo $NODE_PATH | tr ":" "\n") -name "express" 2>/dev/null || echo "Express not found in NODE_PATH"' >> /app/start.sh && \
    echo '  echo "Starting Node with debugging..."' >> /app/start.sh && \
    echo '  NODE_OPTIONS="--max-old-space-size=512" node $(basename $BACKEND_INDEX) || { echo "Backend failed to start: $?"; exit 1; }' >> /app/start.sh && \
    echo 'elif [ "$SERVICE_TYPE" = "frontend" ]; then' >> /app/start.sh && \
    echo '  echo "Starting frontend service..."' >> /app/start.sh && \
    echo '  echo "Checking frontend static files..."' >> /app/start.sh && \
    echo '  if [ ! -d "/app/packages/web/frontend/dist" ]; then' >> /app/start.sh && \
    echo '    echo "ERROR: Frontend build directory does not exist"' >> /app/start.sh && \
    echo '    exit 1' >> /app/start.sh && \
    echo '  fi' >> /app/start.sh && \
    echo '  ls -la /app/packages/web/frontend/dist || echo "Could not list frontend files"' >> /app/start.sh && \
    echo '  # Generate runtime env config file with dynamic environment variables' >> /app/start.sh && \
    echo '  echo "Generating runtime environment config..."' >> /app/start.sh && \
    echo '  mkdir -p /app/packages/web/frontend/dist/config' >> /app/start.sh && \
    echo '  echo "window.RUNTIME_CONFIG = {" > /app/packages/web/frontend/dist/config/runtime-env.js' >> /app/start.sh && \
    echo '  # Use relative URL in production to avoid CORS and hostname issues' >> /app/start.sh && \
    echo '  if [ "$NODE_ENV" = "production" ]; then' >> /app/start.sh && \
    echo '    echo "  API_URL: \"/api\"," >> /app/packages/web/frontend/dist/config/runtime-env.js' >> /app/start.sh && \
    echo '    echo "  Using relative API URL in production: /api"' >> /app/start.sh && \
    echo '  else' >> /app/start.sh && \
    echo '    echo "  API_URL: \"${VITE_API_URL:-http://chronosync-backend:3005/api}\"," >> /app/packages/web/frontend/dist/config/runtime-env.js' >> /app/start.sh && \
    echo '    echo "  Using explicit API URL: ${VITE_API_URL:-http://chronosync-backend:3005/api}"' >> /app/start.sh && \
    echo '  fi' >> /app/start.sh && \
    echo '  echo "  ENV: \"${NODE_ENV:-production}\"," >> /app/packages/web/frontend/dist/config/runtime-env.js' >> /app/start.sh && \
    echo '  echo "  TIMESTAMP: \"$(date)\"" >> /app/packages/web/frontend/dist/config/runtime-env.js' >> /app/start.sh && \
    echo '  echo "};" >> /app/packages/web/frontend/dist/config/runtime-env.js' >> /app/start.sh && \
    echo '  echo "Runtime environment config created:"' >> /app/start.sh && \
    echo '  cat /app/packages/web/frontend/dist/config/runtime-env.js' >> /app/start.sh && \
    echo '  # Inject script tag into index.html' >> /app/start.sh && \
    echo '  sed -i '"'"'s|</head>|<script src="/config/runtime-env.js"></script></head>|'"'"' /app/packages/web/frontend/dist/index.html' >> /app/start.sh && \
    echo '  echo "Starting nginx server..."' >> /app/start.sh && \
    echo '  echo "Nginx configuration content:"' >> /app/start.sh && \
    echo '  cat /nginx/frontend.conf' >> /app/start.sh && \
    echo '  nginx -c /nginx/frontend.conf -g "daemon off;"' >> /app/start.sh && \
    echo 'else' >> /app/start.sh && \
    echo '  echo "ERROR: SERVICE_TYPE must be set to frontend or backend"' >> /app/start.sh && \
    echo '  exit 1' >> /app/start.sh && \
    echo 'fi' >> /app/start.sh && \
    chmod +x /app/start.sh

# Expose ports for both services
EXPOSE 3005 80

# Set entrypoint to our start script
ENTRYPOINT ["/app/start.sh"] 