# Use a specific node version for better compatibility
FROM node:20-alpine

# Set environment variables
ENV NODE_ENV=production
ENV NX_DAEMON=false
ENV NX_VERBOSE_LOGGING=true
ENV DEBUG=nx*

# Install pnpm and nx globally
RUN echo "=== [1] Installing pnpm and nx ===" && \
    npm install -g pnpm@10.6.1 nx

# Install wget for health checks
RUN apk add --no-cache wget nginx

# Set working directory
WORKDIR /app

# Copy the entire project
COPY . .

# Show node and npm versions for debugging
RUN echo "=== [2] Node/NPM Version Info ===" && \
    node --version && \
    npm --version && \
    pnpm --version && \
    nx --version

# Check pnpm-workspace.yaml and package structure
RUN echo "=== [3] Checking workspace configuration ===" && \
    cat pnpm-workspace.yaml && \
    echo "\n=== Package.json content ===" && \
    cat package.json

# Install all dependencies with better error reporting
RUN echo "=== [4] Installing dependencies ===" && \
    pnpm install --no-frozen-lockfile || (echo "PNPM install failed with error code $?" && exit 1)

# Check for @chronosync/common package
RUN echo "=== [5] Checking for common package ===" && \
    ls -la packages/web/common && \
    echo "\n=== Common package.json content ===" && \
    cat packages/web/common/package.json

# Check for backend and frontend packages
RUN echo "=== [6] Checking for backend package ===" && \
    ls -la packages/web/backend && \
    echo "\n=== Backend package.json content ===" && \
    cat packages/web/backend/package.json && \
    echo "\n=== [7] Checking for frontend package ===" && \
    ls -la packages/web/frontend && \
    echo "\n=== Frontend package.json content ===" && \
    cat packages/web/frontend/package.json

# List node_modules to check if dependencies are installed correctly
RUN echo "=== [8] Checking node_modules for workspace packages ===" && \
    ls -la node_modules/@chronosync || echo "No @chronosync in node_modules!"

# Build common package first with detailed logging
RUN echo "=== [9] Building common package ===" && \
    NX_VERBOSE_LOGGING=true pnpm build:web:common || \
    (echo "\n=== Common build FAILED with error code $? ===\n" && \
     echo "Nx.json content:" && cat nx.json && \
     echo "\nLooking for nx cache:" && ls -la .nx && \
     exit 1)

# Check if common package was built successfully
RUN echo "=== [10] Verifying common package build outputs ===" && \
    ls -la packages/web/common/dist || echo "No dist folder found for common package!"

# Build backend with detailed logging
RUN echo "=== [11] Building backend package ===" && \
    (NX_VERBOSE_LOGGING=true DEBUG=nx* pnpm build:web:backend || \
    (echo "\n=== Backend build FAILED with error code $? ===\n" && \
     echo "Checking tsconfig files:" && \
     cat packages/web/backend/tsconfig.json && \
     echo "\nBackend source files:" && \
     ls -la packages/web/backend/src && \
     exit 1))

# Check if backend was built successfully
RUN echo "=== [12] Verifying backend build outputs ===" && \
    ls -la dist/packages/web/backend || echo "No dist folder found for backend package!"

# Add health check page to frontend
RUN echo "=== Adding health check page to frontend ===" && \
    mkdir -p packages/web/frontend/public && \
    echo '<!DOCTYPE html><html><head><title>Health Check</title></head><body><h1>OK</h1><p>Frontend is healthy</p><script>document.body.appendChild(document.createTextNode("Timestamp: " + new Date().toISOString()))</script></body></html>' > packages/web/frontend/public/health.html

# Build frontend with detailed logging
RUN echo "=== [13] Building frontend package ===" && \
    (NX_VERBOSE_LOGGING=true DEBUG=nx* pnpm build:web:frontend || \
    (echo "\n=== Frontend build FAILED with error code $? ===\n" && \
     echo "Checking tsconfig files:" && \
     cat packages/web/frontend/tsconfig.json && \
     echo "\nFrontend source files:" && \
     ls -la packages/web/frontend/src && \
     exit 1))

# Check if frontend was built successfully
RUN echo "=== [14] Verifying frontend build outputs ===" && \
    ls -la packages/web/frontend/dist || echo "No dist folder found for frontend package!"

# Create frontend-specific nginx configuration with health check path
RUN mkdir -p /nginx
RUN echo 'server { \
    listen 80; \
    root /app/packages/web/frontend/dist; \
    index index.html; \
    # Health check endpoint \
    location = /health { \
        access_log off; \
        add_header Content-Type text/plain; \
        return 200 "ok"; \
    } \
    # Regular application routes \
    location / { \
        try_files $uri $uri/ /index.html; \
    } \
}' > /nginx/frontend.conf

# Create a wait-for-postgres script
RUN echo '#!/bin/sh' > /app/wait-for-postgres.sh && \
    echo 'set -e' >> /app/wait-for-postgres.sh && \
    echo 'host="$1"' >> /app/wait-for-postgres.sh && \
    echo 'shift' >> /app/wait-for-postgres.sh && \
    echo 'port="$1"' >> /app/wait-for-postgres.sh && \
    echo 'shift' >> /app/wait-for-postgres.sh && \
    echo 'cmd="$@"' >> /app/wait-for-postgres.sh && \
    echo '' >> /app/wait-for-postgres.sh && \
    echo 'echo "Waiting for PostgreSQL at $host:$port..."' >> /app/wait-for-postgres.sh && \
    echo 'max_attempts=30' >> /app/wait-for-postgres.sh && \
    echo 'attempt=0' >> /app/wait-for-postgres.sh && \
    echo 'until nc -z "$host" "$port" > /dev/null 2>&1; do' >> /app/wait-for-postgres.sh && \
    echo '  attempt=$((attempt+1))' >> /app/wait-for-postgres.sh && \
    echo '  if [ $attempt -ge $max_attempts ]; then' >> /app/wait-for-postgres.sh && \
    echo '    echo "Postgres still unavailable after $max_attempts attempts - giving up"' >> /app/wait-for-postgres.sh && \
    echo '    exit 1' >> /app/wait-for-postgres.sh && \
    echo '  fi' >> /app/wait-for-postgres.sh && \
    echo '  >&2 echo "Postgres is unavailable on $host:$port - sleeping (attempt $attempt/$max_attempts)"' >> /app/wait-for-postgres.sh && \
    echo '  sleep 1' >> /app/wait-for-postgres.sh && \
    echo 'done' >> /app/wait-for-postgres.sh && \
    echo '' >> /app/wait-for-postgres.sh && \
    echo '>&2 echo "Postgres is up at $host:$port - executing command"' >> /app/wait-for-postgres.sh && \
    echo 'exec $cmd' >> /app/wait-for-postgres.sh && \
    chmod +x /app/wait-for-postgres.sh

# Install netcat for the wait script
RUN apk add --no-cache netcat-openbsd

# Create startup script to run both services with proper health checks
RUN echo '#!/bin/sh' > /app/start.sh && \
    echo 'if [ "$SERVICE_TYPE" = "backend" ]; then' >> /app/start.sh && \
    echo '    echo "Starting backend service..."' >> /app/start.sh && \
    echo '    cd /app' >> /app/start.sh && \
    echo '    # Add environment check and setup' >> /app/start.sh && \
    echo '    echo "Environment: $NODE_ENV"' >> /app/start.sh && \
    echo '    echo "Port: $PORT"' >> /app/start.sh && \
    echo '    echo "Database URL: $DATABASE_URL"' >> /app/start.sh && \
    echo '    echo "DB Host: $DB_HOST"' >> /app/start.sh && \
    echo '    echo "Health check URL will be: http://localhost:$PORT/api/health"' >> /app/start.sh && \
    echo '    # Create a simple health check endpoint if it doesn'"'"'t exist' >> /app/start.sh && \
    echo '    mkdir -p dist/packages/web/backend/src/routes' >> /app/start.sh && \
    echo '    if ! grep -r "api/health" dist/packages/web/backend/ > /dev/null; then' >> /app/start.sh && \
    echo '        echo "Warning: No health check endpoint found in built files. Attempting to inject one."' >> /app/start.sh && \
    echo '        # Try to inject directly into compiled files' >> /app/start.sh && \
    echo '        /app/inject-health.sh' >> /app/start.sh && \
    echo '        # Create the fallback health endpoint if injection fails' >> /app/start.sh && \
    echo '        if ! grep -r "api/health" dist/packages/web/backend/ > /dev/null; then' >> /app/start.sh && \
    echo '            echo "Direct injection failed. Creating fallback health endpoint module."' >> /app/start.sh && \
    echo '            cat > dist/packages/web/backend/src/healthCheck.js << EOF' >> /app/start.sh && \
    echo '// Simple health check endpoint added at startup' >> /app/start.sh && \
    echo 'const express = require("express");' >> /app/start.sh && \
    echo 'const router = express.Router();' >> /app/start.sh && \
    echo 'router.get("/health", (req, res) => {' >> /app/start.sh && \
    echo '  res.status(200).json({ status: "ok", timestamp: new Date().toISOString() });' >> /app/start.sh && \
    echo '});' >> /app/start.sh && \
    echo 'module.exports = router;' >> /app/start.sh && \
    echo 'EOF' >> /app/start.sh && \
    echo '            echo "const healthCheck = require(\\\"./healthCheck\\\"); app.use(\\\"/api\\\", healthCheck);" >> dist/packages/web/backend/src/index.js' >> /app/start.sh && \
    echo '        fi' >> /app/start.sh && \
    echo '    else' >> /app/start.sh && \
    echo '        echo "Health check endpoint found, proceeding with startup"' >> /app/start.sh && \
    echo '    fi' >> /app/start.sh && \
    echo '    # Wait for postgres and then start the backend' >> /app/start.sh && \
    echo '    echo "Running wait-for-postgres script..."' >> /app/start.sh && \
    echo '    # Start the backend and capture its PID' >> /app/start.sh && \
    echo '    /app/wait-for-postgres.sh $DB_HOST $DB_PORT NODE_OPTIONS="--max-old-space-size=512 --trace-warnings" node dist/packages/web/backend/index.js & backend_pid=$!' >> /app/start.sh && \
    echo '    echo "Backend started with PID: $backend_pid"' >> /app/start.sh && \
    echo '    # Wait for application to initialize (adjust sleep time as needed)' >> /app/start.sh && \
    echo '    sleep 5' >> /app/start.sh && \
    echo '    # Run the debug script to check if health endpoint is working' >> /app/start.sh && \
    echo '    echo "Running debug health check..."' >> /app/start.sh && \
    echo '    /app/debug-health.sh' >> /app/start.sh && \
    echo '    # Keep container running by waiting for the backend process' >> /app/start.sh && \
    echo '    wait $backend_pid || echo "Backend exited with code: $?"' >> /app/start.sh && \
    echo 'elif [ "$SERVICE_TYPE" = "frontend" ]; then' >> /app/start.sh && \
    echo '    echo "Starting frontend service..."' >> /app/start.sh && \
    echo '    # Create a health check file that nginx can serve' >> /app/start.sh && \
    echo '    echo "OK" > /app/packages/web/frontend/dist/health' >> /app/start.sh && \
    echo '    # Start nginx with our custom config' >> /app/start.sh && \
    echo '    nginx -c /nginx/frontend.conf -g "daemon off;"' >> /app/start.sh && \
    echo 'else' >> /app/start.sh && \
    echo '    echo "SERVICE_TYPE environment variable must be set to either frontend or backend"' >> /app/start.sh && \
    echo '    exit 1' >> /app/start.sh && \
    echo 'fi' >> /app/start.sh && \
    chmod +x /app/start.sh

# Expose ports for both services
EXPOSE 3005 80

# Set entrypoint to our start script
ENTRYPOINT ["/app/start.sh"]

# Install utilities for debugging
RUN apt-get update && apt-get install -y wget netcat-openbsd curl procps lsof nano vim && apt-get clean

# Create a debug script to check the health endpoint
RUN echo '#!/bin/sh' > /app/debug-health.sh && \
    echo 'echo "Checking health endpoint..."' >> /app/debug-health.sh && \
    echo 'echo "Process list:"' >> /app/debug-health.sh && \
    echo 'ps aux | grep node' >> /app/debug-health.sh && \
    echo 'echo "Open ports:"' >> /app/debug-health.sh && \
    echo 'lsof -i -P -n | grep LISTEN' >> /app/debug-health.sh && \
    echo 'echo "Trying to connect to health endpoint..."' >> /app/debug-health.sh && \
    echo 'curl -v http://localhost:$PORT/api/health' >> /app/debug-health.sh && \
    echo 'echo "Exit code: $?"' >> /app/debug-health.sh && \
    chmod +x /app/debug-health.sh

# Create a script to inject a health endpoint directly into app.js
RUN echo '#!/bin/sh' > /app/inject-health.sh && \
    echo 'set -e' >> /app/inject-health.sh && \
    echo 'echo "Attempting to inject health endpoint directly into compiled files..."' >> /app/inject-health.sh && \
    echo 'APP_FILE=$(find /app/dist/packages/web/backend -name "index.js" -type f)' >> /app/inject-health.sh && \
    echo 'if [ -f "$APP_FILE" ]; then' >> /app/inject-health.sh && \
    echo '  echo "Found app file: $APP_FILE"' >> /app/inject-health.sh && \
    echo '  # Check if app.get("/api/health") already exists' >> /app/inject-health.sh && \
    echo '  if ! grep -q "app.get..*/api/health" "$APP_FILE"; then' >> /app/inject-health.sh && \
    echo '    # Find app.listen or app.use - typically towards the end of the file before the server starts' >> /app/inject-health.sh && \
    echo '    # Create a backup first' >> /app/inject-health.sh && \
    echo '    cp "$APP_FILE" "${APP_FILE}.bak"' >> /app/inject-health.sh && \
    echo '    # Use sed to insert the health endpoint before app.listen' >> /app/inject-health.sh && \
    echo '    # Define the health check code to inject' >> /app/inject-health.sh && \
    echo '    HEALTH_CODE="// Injected health check endpoint\napp.get(\"/api/health\", (req, res) => {\n  res.status(200).json({ status: \"ok\", timestamp: new Date().toISOString() });\n});\n"' >> /app/inject-health.sh && \
    echo '    # Insert before app.listen or at the end if not found' >> /app/inject-health.sh && \
    echo '    if grep -q "app.listen" "$APP_FILE"; then' >> /app/inject-health.sh && \
    echo '      sed -i -e "/app.listen/ i\\$HEALTH_CODE" "$APP_FILE"' >> /app/inject-health.sh && \
    echo '      echo "Inserted health endpoint before app.listen"' >> /app/inject-health.sh && \
    echo '    elif grep -q "app.use" "$APP_FILE"; then' >> /app/inject-health.sh && \
    echo '      # If no app.listen, try to inject after last app.use' >> /app/inject-health.sh && \
    echo '      LAST_APP_USE=$(grep -n "app.use" "$APP_FILE" | tail -1 | cut -d: -f1)' >> /app/inject-health.sh && \
    echo '      if [ -n "$LAST_APP_USE" ]; then' >> /app/inject-health.sh && \
    echo '        LAST_APP_USE=$((LAST_APP_USE + 1))' >> /app/inject-health.sh && \
    echo '        sed -i -e "${LAST_APP_USE}i\\$HEALTH_CODE" "$APP_FILE"' >> /app/inject-health.sh && \
    echo '        echo "Inserted health endpoint after last app.use"' >> /app/inject-health.sh && \
    echo '      else' >> /app/inject-health.sh && \
    echo '        echo "Could not find suitable location to inject health endpoint"' >> /app/inject-health.sh && \
    echo '      fi' >> /app/inject-health.sh && \
    echo '    else' >> /app/inject-health.sh && \
    echo '      echo "Could not find suitable location to inject health endpoint"' >> /app/inject-health.sh && \
    echo '    fi' >> /app/inject-health.sh && \
    echo '    echo "Health endpoint injection attempt completed. Original file backed up at ${APP_FILE}.bak"' >> /app/inject-health.sh && \
    echo '  else' >> /app/inject-health.sh && \
    echo '    echo "Health endpoint already exists in the app file"' >> /app/inject-health.sh && \
    echo '  fi' >> /app/inject-health.sh && \
    echo 'else' >> /app/inject-health.sh && \
    echo '  echo "Could not find app file"' >> /app/inject-health.sh && \
    echo 'fi' >> /app/inject-health.sh && \
    chmod +x /app/inject-health.sh 